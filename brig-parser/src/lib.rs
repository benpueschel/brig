//! The parser crate is responsible for parsing the tokens generated by the [`::brig_lexer::Lexer`]
//! into an abstract syntax tree, encoding the structure of the program.

use brig_ast::*;
use brig_common::Span;
use brig_diagnostic::{Error, Result};
use brig_lexer::{Lexer, Token, TokenKind};
use brig_macros::verify_token;

mod decl;
mod expr;
mod stmt;

/// A helper function to create an error message for an unexpected token, where an identifier was
/// expected.
pub fn expected_ident(token: &Token) -> Error {
    Error::expected_token(
        token.kind.to_string(),
        vec!["identifier".to_string()],
        token.span,
    )
}

/// A helper function parsing an identifier ast node from an identifier token.
pub fn ident_from_token(token: Token) -> Result<Identifier> {
    match token.kind {
        TokenKind::Identifier(ident) => Ok(Identifier {
            name: ident,
            span: token.span,
        }),
        _ => Err(expected_ident(&token)),
    }
}

/// The Parser struct generates an abstract syntax tree from the given lexer.
pub struct Parser {
    lexer: Lexer,
}

impl Parser {
    pub fn new(lexer: Lexer) -> Self {
        Self { lexer }
    }

    /// Get the next token, without advancing the lexer.
    pub fn peek(&self) -> Result<Token> {
        self.lexer.peek()
    }
    /// Get the next token from the lexer and advance it.
    pub fn eat(&mut self) -> Result<Token> {
        self.lexer.next_token()
    }
    /// Get the next token from the lexer and only advance it if the given predicate returns true.
    pub fn eat_if<F, R>(&mut self, mut f: F) -> Result<R>
    where
        F: FnMut(&Token) -> Result<R>,
    {
        let token = self.peek()?;
        let result = f(&token);
        if result.is_ok() {
            self.eat()?;
        }
        result
    }

    /// The top-level parsing function, parsing a [`::brig_ast::Program`] from the lexer.
    pub fn parse_program(&mut self) -> Result<Program> {
        let mut program = Program::default();
        while self.peek()?.kind != TokenKind::EOF {
            program.declarations.push(self.parse_declaration()?);
        }
        Ok(program)
    }

    /// Parse a single block of code, containing a series of statements.
    pub fn parse_block(&mut self) -> Result<Block> {
        verify_token!(self.eat()?, TokenKind::BraceOpen);

        let mut statements = Vec::new();
        while self.peek()?.kind != TokenKind::BraceClose {
            statements.push(self.parse_statement()?);
        }

        verify_token!(self.eat()?, TokenKind::BraceClose);

        let span = Span::compose(
            statements.first().map(|s| s.span()).unwrap_or_default(),
            statements.last().map(|s| s.span()).unwrap_or_default(),
        );

        Ok(Block { span, statements })
    }

    /// Parse an optional [`::brig_ast::Ty`] from the lexer. Types are always preceded by a colon.
    /// If no colon is found, the returned Type is `Ty::Unspecified`.
    pub fn parse_type(&mut self) -> Result<Ty> {
        if !matches!(self.peek()?.kind, TokenKind::Colon) {
            return Ok(Ty {
                kind: TyKind::Unspecified,
                span: Span::with_len(self.peek()?.span.start, 0),
            });
        }

        self.eat()?;
        let token = self.peek()?;
        match &token.kind {
            TokenKind::Identifier(_) => {
                let ident = ident_from_token(self.eat()?)?;
                let span = ident.span;
                let kind = match ident.name.as_str() {
                    "u32" => TyKind::Literal(LiteralType::Uint(UintType::U32)),
                    "usize" => TyKind::Literal(LiteralType::Uint(UintType::Usize)),
                    _ => TyKind::UserDefined(ident),
                };
                Ok(Ty { kind, span })
            }
            _ => Err(expected_ident(&token)),
        }
    }
}

#[cfg(test)]
mod test {
    use crate::*;
    #[test]
    pub fn parse_empty_type() {
        let input = "";
        let lexer = Lexer::new(input.to_string());
        let mut parser = Parser::new(lexer);
        let ty = parser.parse_type().expect("Failed to parse type");
        assert_eq!(
            ty,
            Ty {
                kind: TyKind::Unspecified,
                span: Span::new(0, 0),
            }
        );
    }

    #[test]
    pub fn parse_usize_type() {
        let input = ": usize";
        let lexer = Lexer::new(input.to_string());
        let mut parser = Parser::new(lexer);
        let ty = parser.parse_type().expect("Failed to parse type");
        assert_eq!(
            ty,
            Ty {
                kind: TyKind::Literal(LiteralType::Uint(UintType::Usize)),
                span: Span::new(2, 7),
            }
        );
    }

    #[test]
    pub fn parse_u32_type() {
        let input = ": u32";
        let lexer = Lexer::new(input.to_string());
        let mut parser = Parser::new(lexer);
        let ty = parser.parse_type().expect("Failed to parse type");
        assert_eq!(
            ty,
            Ty {
                kind: TyKind::Literal(LiteralType::Uint(UintType::U32)),
                span: Span::new(2, 5),
            }
        );
    }

    #[test]
    pub fn parse_user_type() {
        let input = ": MyType";
        let lexer = Lexer::new(input.to_string());
        let mut parser = Parser::new(lexer);
        let ty = parser.parse_type().expect("Failed to parse type");
        assert_eq!(
            ty,
            Ty {
                kind: TyKind::UserDefined(Identifier {
                    name: "MyType".to_string(),
                    span: Span::new(2, 8),
                }),
                span: Span::new(2, 8),
            }
        );
    }
}
