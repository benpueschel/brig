//! The parser crate is responsible for parsing the tokens generated by the [`::brig_lexer::Lexer`]
//! into an abstract syntax tree, encoding the structure of the program.

use brig_ast::*;
use brig_common::{path, Span};
use brig_diagnostic::{Error, Result};
use brig_lexer::{Lexer, Token, TokenKind};
use brig_macros::verify_token;
use thin_vec::ThinVec;

mod adt;
mod block;
mod decl;
mod expr;
mod stmt;

/// A helper function to create an error message for an unexpected token, where an identifier was
/// expected.
pub fn expected_ident(token: &Token) -> Error {
    Error::expected_token(
        token.kind.to_string(),
        vec!["identifier".to_string()],
        token.span,
    )
}

/// A helper function parsing an identifier ast node from an identifier token.
pub fn ident_from_token(token: Token) -> Result<Ident> {
    match token.kind {
        TokenKind::Identifier(ident) => Ok(Ident {
            name: ident,
            span: token.span,
        }),
        _ => Err(expected_ident(&token)),
    }
}

/// The Parser struct generates an abstract syntax tree from the given lexer.
pub struct Parser {
    lexer: Lexer,
}

impl Parser {
    pub fn new(lexer: Lexer) -> Self {
        Self { lexer }
    }

    /// Get the next token, without advancing the lexer.
    pub fn peek(&self) -> Result<Token> {
        self.lexer.peek()
    }
    /// Get the next token from the lexer and advance it.
    pub fn eat(&mut self) -> Result<Token> {
        self.lexer.next_token()
    }
    /// Get the next token from the lexer and only advance it if the given predicate returns true.
    pub fn eat_if<F, R>(&mut self, mut f: F) -> Result<R>
    where
        F: FnMut(&Token) -> Result<R>,
    {
        let token = self.peek()?;
        let result = f(&token);
        if result.is_ok() {
            self.eat()?;
        }
        result
    }

    /// The top-level parsing function, parsing a [`::brig_ast::Program`] from the lexer.
    pub fn parse_program(&mut self) -> Result<Program> {
        let mut program = Program::default();
        while self.peek()?.kind != TokenKind::EOF {
            program.declarations.push(self.parse_declaration()?);
        }
        Ok(program)
    }

    /// Parse a punctuation-separated list of elements enclosed by parenthesis, where each element
    /// is parsed by the given function `f`.
    ///
    /// The function `f` should return the parsed element, or an error if the element could not be
    /// parsed.
    /// The function `f` should consume any tokens it needs to parse the element, but not consume
    /// any punctuation tokens, or the closing parenthesis.
    pub fn parse_punctuated_list<T, F>(&mut self, punct: TokenKind, f: F) -> Result<Punctuated<T>>
    where
        F: Fn(&mut Parser) -> Result<T>,
    {
        verify_token!(self.eat()?, TokenKind::ParenOpen);

        let mut elements = ThinVec::new();
        let mut span = self.peek()?.span;

        if self.peek()?.kind == TokenKind::ParenClose {
            self.eat()?;
            return Ok(Punctuated { elements, span });
        }

        loop {
            span = Span::compose(span, self.peek()?.span);
            elements.push(f(self)?);
            let token = self.peek()?;

            if token.kind == TokenKind::ParenClose {
                break;
            }
            if token.kind != punct {
                return Err(Error::expected_token(
                    token.kind.to_str(),
                    vec![
                        punct.to_str().to_string(),
                        TokenKind::ParenClose.to_str().to_string(),
                    ],
                    token.span,
                ));
            }
            self.eat()?;
        }

        verify_token!(self.eat()?, TokenKind::ParenClose);
        Ok(Punctuated { elements, span })
    }

    /// Parse an optional [`::brig_ast::Ty`] from the lexer. Types are always preceded by a colon.
    /// If no colon is found, the returned Type is `Ty::Unspecified`.
    pub fn parse_type(&mut self) -> Result<Ty> {
        if !matches!(self.peek()?.kind, TokenKind::Colon) {
            return Ok(Ty {
                kind: TyKind::Unspecified,
                span: Span::with_len(self.peek()?.span.start, 0),
            });
        }

        self.eat()?;
        let token = self.peek()?;
        match &token.kind {
            TokenKind::Identifier(_) => {
                let ident = ident_from_token(self.eat()?)?;
                let path = path!(ident.span, ident.name);
                let span = path.span;

                let kind = match path.to_string().as_str() {
                    "u32" => TyKind::Lit(LitTy::Uint(UintTy::U32)),
                    "usize" => TyKind::Lit(LitTy::Uint(UintTy::Usize)),
                    "bool" => TyKind::Lit(LitTy::Bool),
                    _ => TyKind::Ident(path),
                };
                Ok(Ty { kind, span })
            }
            _ => Err(expected_ident(&token)),
        }
    }
}

#[cfg(test)]
mod test {
    use brig_common::sym;
    use thin_vec::thin_vec;

    use crate::*;
    #[test]
    pub fn parse_empty_type() {
        let input = "";
        let lexer = Lexer::new(input.to_string());
        let mut parser = Parser::new(lexer);
        let ty = parser.parse_type().expect("Failed to parse type");
        assert_eq!(
            ty,
            Ty {
                kind: TyKind::Unspecified,
                span: Span::new(0, 0),
            }
        );
    }

    #[test]
    pub fn parse_usize_type() {
        let input = ": usize";
        let lexer = Lexer::new(input.to_string());
        let mut parser = Parser::new(lexer);
        let ty = parser.parse_type().expect("Failed to parse type");
        assert_eq!(
            ty,
            Ty {
                kind: TyKind::Lit(LitTy::Uint(UintTy::Usize)),
                span: Span::new(2, 7),
            }
        );
    }

    #[test]
    pub fn parse_u32_type() {
        let input = ": u32";
        let lexer = Lexer::new(input.to_string());
        let mut parser = Parser::new(lexer);
        let ty = parser.parse_type().expect("Failed to parse type");
        assert_eq!(
            ty,
            Ty {
                kind: TyKind::Lit(LitTy::Uint(UintTy::U32)),
                span: Span::new(2, 5),
            }
        );
    }

    #[test]
    pub fn parse_user_type() {
        let input = ": MyType";
        let lexer = Lexer::new(input.to_string());
        let mut parser = Parser::new(lexer);
        let ty = parser.parse_type().expect("Failed to parse type");
        assert_eq!(
            ty,
            Ty {
                kind: TyKind::Ident(path!(Span::new(2, 8), sym!("MyType"))),
                span: Span::new(2, 8),
            }
        );
    }
}
